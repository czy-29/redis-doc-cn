[注意：这是 Redis 宣言，有关
      安装和运行 Redis 的一般信息，请阅读 README 文件。]

Redis宣言
===============

1 - 抽象数据类型的 DSL。Redis 是一种 DSL（领域特定语言），
    它处理抽象数据类型并作为 TCP 守护进程实现。
    用命令来操作键空间，其中键是二进制安全字符串，
    值是不同类型的抽象数据类型。每种数据类型
    都代表基本数据结构的抽象版本。例如，
    Redis 列表是链表的抽象表示。在 Redis 中，
    数据类型的本质不仅仅包含数据类型支持的
    操作类型，还包括数据类型的空间和时间复杂度以及
    对其执行的操作。（译者注：最后这一句话译者表示也没看懂，有理解了这句的原文的朋友，欢迎提交pr修改我这句的翻译）

2 - 内存存储是一等公民。Redis 数据集由定义好的键值
    对组成，主要存储在计算机的内存中。包括入门级服务器
    在内的各种计算机的内存量每年
    都在显着增加。内存速度很快，并且允许 Redis 具有非常
    可预测的性能。由 10k 或是 4000 万个键组成的数据集将
    具有类似的性能。Redis Sorted Sets 等复杂数据类型
    在内存中易于实现和操作，性能良好，使得 Redis 非常
    简单。Redis 将继续探索替代选项（例如，数据可以
    选择性地存储在磁盘上），但该项目的主要目标仍然是
    开发内存数据库。

3 - 基本数据结构配合基本 API。Redis API 是基本
    数据结构的直接结果。API 通常可以是任意编写的，
    但这不同于基本数据结构性质的 API。如果我们
    遇到来自宇宙另一部分的智能生命形式，他们
    可能会知道、理解和识别我们在计算机科学书籍
    中所拥有的相同基本数据结构。Redis 在 API 中会避免中间层，
    因为这样复杂性就很明显了。可以将更复杂的操作
    作为基本操作的组合来进行。

4 - 我们相信代码效率。计算机变得越来越快，但我们
    认为滥用计算能力是不明智的：对于给定的
    能量，您可以执行的操作数量无论如何仍然是一个
    重要参数：它允许用更少的计算机做更多的事情，同
    时 ，对环境的影响更小。同样，Redis
    能够“收缩”到更小的设备。它完全适用于
    树莓派和其他基于 ARM 的小型计算机。更快，
    且仅具有真正需要的抽象层的代码，通常也会带来
    更可预测的性能。我们还会继续探索内存
    使用，Redis 项目的基本目标之一是
    逐步构建越来越多内存高效的数据结构，以便
    使过去在 RAM 中无法解决的问题在未来
    完全可以解决。

5 - 代码就像一首诗； 这不仅仅是我们为了达到一些实际结果
    而写的东西。有时，远离 Redis 哲学的人
    会建议使用其他作者编写的其他代码（通常使用其他
    语言）来实现 Redis 目前所缺乏的东西。但对我们来说，
    这就像莎士比亚决定使用《神曲》（译者注：但丁创作的长诗）中的《天堂》来结束
    他的《亨利四世》一样。使用任何外部代码是一个坏主意吗？一点也不。就像
    在“一千零一夜”中一样，较小的自包含故事嵌入
    到更大的故事中，我们很乐意在需要时使用漂亮的
    自包含库。同时，在编写 Redis 故事时，我们会尝试
    编写适合代码库其它部分的较小故事。

6 - 我们反对复杂性。我们相信系统设计是与复杂性的
    斗争。我们会接受在值得时与复杂性作斗争，但
    我们会努力识别何时一个小功能不值得 1000 行
    代码。大多数时候，对抗复杂性的最佳方法是根本
    不创建它。复杂性也是一种锁定形式：无论
    许可证如何，用户都无法以独立的方式修改
    非常难以理解的代码。Redis 的主要目标之一是保持
    可理解性，要能够让一个程序员在几周内通过
    阅读源代码就可以清楚地了解它的详细工作原理。

7 - 线程不是灵丹妙药。我们更相信高效（主要考量）的单线程 Redis 核心
    的做法，而不是让 Redis 多线程化。
    多个这样的核心，可能在同一台计算机上运行，也可能在多台计算机
    上运行，通过更高阶的协议和功能被抽象为
    一个单一的大系统：Redis 集群和即将推出的
    Redis 代理是我们的主要目标。无共享手段不仅
    简单得多（请参阅本文档中的前一点），而且在 NUMA 系统中
    也是最佳选择。在 Redis 这种特定系统下，它允许每个实例
    拥有更有限的数据量，从而使 Redis persist-by-fork
    方法更合理。将来，我们可能会仅针对 I/O 探索
    并行性，这是一个容易实现的目标：最小的复杂性就可以提供
    有提升的单进程体验。

8 - 两个级别的 API。Redis API 有两个级别：1) API 的一个子集天然
    适合分布式版本的 Redis。2) 支持多键操作的
    更复杂的 API。如果明智地使用，两者都是有用的，但是
    没有办法在不违反我们其他原则的情况下以
    不透明的方式让更复杂的多键 API 变为分布式。我们不想提供
    一种幻觉，认为它可以神奇地工作，而实际上它并不是在所有的情况下
    都可以。相反，我们将提供命令来快速将键从一个实例
    迁移到另一个实例，以执行多键操作并将
    权衡交给用户。

9 - 我们为快乐而优化。我们相信编写代码是一项艰巨的工作，
    唯一值得的方法就是享受它。当编写代码不再有
    乐趣时，最好的办法就是停下来。为了防止这种情况发生，我们将避免
    采用会使 Redis 开发变得不那么有趣的路径。

10 - 以上所有要点都集中在我们所说的机会主义
     编程中：尝试以最小的复杂性为用户增加
     最大收益（目标）。在可以接受的情况下，用 5% 的代码
     解决 95% 的问题。避免固定的时间表，但要遵循
     用户请求流、灵感流、以及 Redis 内部对某些功能的准备情况
     （有时许多过去的更改达到了临界点，使以前
     复杂的功能非常容易实现）。
